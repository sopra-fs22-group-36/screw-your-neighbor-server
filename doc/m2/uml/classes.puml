@startuml
'https://plantuml.com/class-diagram

CardSource <|.. Deck
Iterable <|.. Deck
Card "1" *-- Rank
Card "1" *-- Suit
Game "1" *-- "1..*" Match
Game *-- ScoreBoard
Score "1" - "1..*" Player
Match "1" *-- "1" AnnouncementRound
Match "1" *-- "1..*" PlayRound
/'Round "1" *-- "1..*" Turn
Turn *-- CardCollectionPlayer'/
Round "1" *-- "1..n" CardCollectionPlayer
ScoreBoard "1" *-- "1..*" Score
PlayRound "1" o-- "1..*" ScoreAchieved
AnnouncementRound "1" o-- "1..*" ScoreAnnounced
User <|-- Player
Round <|-- AnnouncementRound
Round <|-- PlayRound
Score <|-- ScoreAnnounced
Score <|-- ScoreAchieved
CardSource <|-- CardCollectionPlayer
CardSource <|-- CardCollectionTable

Player "1..*" - "1" Game
Player "1" - "1" CardCollectionPlayer
PlayRound "1" *-- "1" CardCollectionTable
Deck "1" - "1..*" Card
/'Lobby "1" - "1..*" Player'/
Round "1" - "1" Action

class Player {
+ receiveCards()
+ playCard()
+ setNewScore()
+ getNewScore()
+ getAnnouncedTricks()
+ getCurrentNumberOfTricks()
+ addTrick()
}

class Game {

Game(players: Player[])

}

class Lobby {

}
note right of Lobby: not sure,\nif needed

class RuleSet {
+ DetermineHighestCard (cardCollection: CardCollection)
+ CalculateAchievedPointsPlayer (player: Player)
+ GetScoreBoard (round: Round)
+ ValidateAnnouncedPoints (round: Round, score: Score)
+ GetNextPlayersTurn()
}
note bottom of RuleSet: HelperClass with check- \nand validation methods

class ScoreBoard {
    +displayScores()
}

class Score {
    points: int
}

class ScoreAnnounced {

}

class ScoreAchieved {

}

class Match {

}
'note left of Match: not sure,\nif needed

abstract class Round {
    + countTricks()
}

class AnnouncementRound {
    + AnnounceTricks()
}

class PlayRound {
    + playCard()
    + calculateScorePerPlayer()
}

enum Rank {
    ASS
    KOENIG
    OBER
    UNDER
    BANNER
    NINE
    EIGHT
    SEVEN
    SIX
}

enum Suit {
    EICHEL
    SCHILTEN
    SCHELLEN
    ROSEN
}

class Card {
    - Rank aRank
    - Suid aSuit
    + Rank getRank()
    + Suit getSuit()
}
note top of Card: This class is immutable

enum Action {
    ANNOUNCE
    PLAY
}
note right of Action: not sure,\nif needed

/'class Turn {
+ Turn (player: Player)
+ announceScore()
+ playCard()
}'/

interface CardSource {
    Card draw()
    boolean isEmpty()
    void shuffle() {Collections.shuffle(aDeck)}
    getCards()
}
note top of CardSource: We can change the source\n by different decks, for example:\n CardSource source = new Deck2()

interface Iterable<Card> {
    + Iterator<Card> iterator()
}

class Deck {
    - List<Card> aDeck: ArrayList
}
note left of Deck: provide Cards as a copy\n not as a pointer

class CardCollectionPlayer {
    + CardCollectionPlayer(cards: Card[])
}
note right of CardCollectionPlayer: "Hand"

class CardCollectionTable {
    + getHighestCard()

}

@enduml